% !TeX root = 191107.tex
\begin{frame}[t]{Автотесты}
	\begin{itemize}
	\item Ручное тестирование с готовым вводом/выводом "--- рутина
	\item Компьютеры хорошо автоматизируют рутину $\Rightarrow$ автотесты
	\item Но тесты "--- это код, за ними тоже надо следить и тестировать
	\item Наивный вид: \textit{интеграционные тесты}, вся программа от начала до конца
		\begin{itemize}
		\item Может быть очень сложно проверить корректность в общем случае
		\item Пример: домашка, grep; надо создавать файлы
		\end{itemize}
	\item Решение: \textbf{тестировать процедуры} (юнит-тесты).
		\begin{itemize}
		\item Не больно, если каждая процедура делает немного и не зависит от остальных.
		\end{itemize}
	\end{itemize}
	Наблюдение: код приятно тестировать $\iff$ он хорошо написан.
\end{frame}

\begin{frame}[t]{Какие тесты писать}
	\begin{itemize}
	\item Простые (smoke test): хоть что-то работает
	\item Крайние случаи (black box):
		\begin{itemize}
		\item Минимальный по размеру; в каждом измерении
		\item Крайние и <<средние>> ограничения в задаче; в каждом измерении
		\item Минимальный/максимальный ответ
		\end{itemize}
	\item Крайние случаи (white box):
		\begin{itemize}
		\item На каждый внутренний \texttt{if}
		\item На каждый внутренний цикл: вдруг (не) выполнится
		\item Можно ещё на комбинации \texttt{if}'ов
		\end{itemize}
	\item Все, где у вас были баги (regression tests):
		\begin{itemize}
		\item Нашли баг
		\item Написали тест
		\item \textit{Проверили, что тест падает}
		\item Исправили
		\item Проверили, что тест проходит
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Пример автотеста}
\begin{minted}{python}
def test_process():
    assert process('1,2,3') == 6
    assert process('4,5,6') == 15
\end{minted}

	Для этого надо, чтобы \t{process} не выводила результат на экран,
	а возвращало.

	Как раз разделение вывода от обработки.
\end{frame}
